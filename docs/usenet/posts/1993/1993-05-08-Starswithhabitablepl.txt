URL: https://groups.google.com/forum/#!topic/rec.arts.sf.science/2Xm6WP5n1F8
TITLE: Stars with habitable planets 

----------------------------------------------------------------------------

Saturday, 8 May 1993 16:22:10 UTC+1 - Arild Toerum:
Could somebody list a number of relatively proximate stars which may
possibly have habitable planets. I am thinking of stars within a range of
50 or so lightyears from Earth, and with possible planets where human
beings could survive. Thanx in advance!
a...@nvg.unit.no <>
----------------------------------------------------------------------------

Saturday, 8 May 1993 19:03:55 UTC+1 - Matt G Gabin:
Arild Toerum (art@tigern.uucp) wrote:
: Could somebody list a number of relatively proximate stars which may- show quoted text -
: possibly have habitable planets. I am thinking of stars within a range of
: 50 or so lightyears from Earth, and with possible planets where human
: beings could survive. Thanx in advance!
: 
: a...@nvg.unit.no <>
: 
Going somewhere, are we???

==============================================================================
Matt Gabin                                Amherst College
"It's good to be the king."                Internet: mgg...@unix.amherst.edu <>
 - Mel Brooks
==============================================================================
----------------------------------------------------------------------------

Sunday, 9 May 1993 20:23:42 UTC+1 - Erik Max Francis:
art@tigern.uucp (Arild Toerum) writes:

> Could somebody list a number of relatively proximate stars which may
> possibly have habitable planets. I am thinking of stars within a range of
> 50 or so lightyears from Earth, and with possible planets where human
> beings could survive. Thanx in advance!
I'd say that it's at least _possible_ that most of the main-sequence 
stars in our neighborhood could have planets, and one of those planets 
could be in the biozone and could be capable of evolving life (because 
there _has_ to be plantlife for you to have a nitrogen-oxygen atmosphere; 
they don't show up on their own).

There are a few stars, such as beta Pic, which appear in the process of 
forming systems, and thus wouldn't have anything we'd be able to use 
Double stars are probably less likely to harbor planets in the biozone, 
because the biozone can change too rapidly.  (There are a few
configurations where it isn't much of a problem:  With a double star, if 
the secondary is very, very far away from the primary, then it doesn't 
interfere with the biozone.  _Or_ you can have a situation where the two 
stars are very bright -- thus the biozone is far away.  The two stars 
could orbit each other fairly closely together, and our potentially 
habitable planet would orbit far away, around their center of mass.  
There might be other more obscure combination (or ones with two stars 
substituted for one in the example, where you have multiple star 
systems).

yet.  I don't recall what the official word is on red dwarfs -- whether 
or not they'd be able to have planets in the biozone and whether or not 
we could use the red light.

But you can pick almost any K or G star, and there are several nearby.



Erik Max Francis, &tSftDotIotE ...!apple!uuwest!max m...@west.darkside.com <>  __
USMail: 1070 Oakmont Dr. #1  San Jose, CA  95117  ICBM: 37 20 N  121 53 W /  \
If you like strategic games of interstellar conquest, ask about UNIVERSE! \__/
-)(- Omnia quia sunt, lumina sunt.  All things that are, are lights. -)(-
----------------------------------------------------------------------------

Monday, 10 May 1993 10:02:02 UTC+1 - Chris Johnson:
there were a couple of book s published on habitable planets.:
one was
        Stephen Dole and I. Asimov,
title was Planets for Man (I think??)
published in late 1960s.

---
Chris Johnson                         phone:        +61 6 249 2624 or 282 1993 (h)
Dept of Computer Science                in Australia (06) 249 2624
Australian National University         AARNet,Internet: c...@cs.anu.edu.au <>
Canberra, ACT 0200                 fax: +61 6 249 0010
----------------------------------------------------------------------------

Monday, 10 May 1993 12:02:06 UTC+1 - David K Fraser:
c...@cs.anu.edu.au <> (Chris Johnson) writes:

>there were a couple of book s published on habitable planets.:
>one was
>        Stephen Dole and I. Asimov,
>title was Planets for Man (I think??)
>published in late 1960s.

John Cramer, a little known physicist-turned-hard-sf-author, has written
a hypercard stack called "Sol's Neighbours". It's floating around on
shareware, and I think it has the information that was being asked for.

-- David F.



-- 
----------------------------------------------------------------------
David K. Fraser,     |                  IMPORTANT!
Student,             | DO NO ATTEMPT TO MAIL A REPLY TO THIS POSTING!
Glasgow University   |    IF YOU DO, YOUR REPLY WILL BOUNCE! HARD!
----------------------------------------------------------------------------

Monday, 10 May 1993 13:41:12 UTC+1 - Del Cotter:
- show quoted text -<1993May8.1...@ugle.unit.no <>> art@tigern.uucp (Arild Toerum) writes:

- show quoted text ->Could somebody list a number of relatively proximate stars which may
>possibly have habitable planets. I am thinking of stars within a range of
>50 or so lightyears from Earth, and with possible planets where human
>beings could survive. Thanx in advance!
from:

Martyn Fogg
"An Estimate of the Prevalence of Biocompatible and Habitable Planets"
J. Brit. Interplanetary Soc. _45_, 3-12 (1992)

Where P(hp) = probability of the occurence of a habitable planet
Where P(hp) = probability of the occurence of a biocompatible planet

Star                        Dist.        Spect.        Mass        P(hp)        P(bp)
                        /ly        Type        /Solar        /%        /%

alpha Centauri A        4.38        G2V        1.1        7.8        44
alpha Centauri B        4.38        K6V        0.89        4.4        38
epsilon Eridani                10.69        K2V        0.8        0.6        34
61 Cygni A                11.17        K5V        0.59        0        5.8
61 Cygni B                11.17        K7V        0.50        0        0.3
epsilon Indi                11.21        K5V        0.71        0        18
Lac 9352                11.69        M2        0.47        0        <0.3
tau Ceti                11.95        G8V        0.82        1.5        35
Lac 8760                12.54        M1V        0.54        0        1.5
Grm 1618                15.03        K7        0.56        0        2.5
70 Ophiuchi A                16.73        K1        0.89        4.4        38
70 Ophiuchi B                16.73        K6        0.68        0        16
36 Ophiuchi A                17.73        K0V        0.77        0        28
36 Ophiuchi B                17.73        K1V        0.76        0        27
36 Ophiuchi C                17.73        K5V        0.63        0        9
HR 7703 A                18.43        K3V        0.76        0        27
sigma Draconis                18.53        K0V        0.82        1.5        35
delta Pavonis                18.64        G5        0.98        5.1        39
eta Cassiopeiae A        19.19        G0V        0.85        3.9        38
eta Cassiopeiae B        19.19        M0        0.52        0        0.7
HD 36395                19.19        M1V        0.51        0        0.5
Wolf 294                19.41        M4        0.49        0        <0.3
+53' 1320 A                19.65        M0        0.52        0        0.6
+53' 1320 B                19.65        M0        0.51        0        0.5
-45' 13677                20.6        M0        0.48        0        <0.3
82 Eridani                20.9        G5        0.91        4.4        38
beta Hydri                21.3        G1        1.23        7.5        35
HR 8832                        21.4        K3        0.74        0        23

-- 
 ',' ' ',','  |                                                  |  ',' ' ',','
   ', ,','    |       Del Cotter       mt9...@brunel.ac.uk <>      |    ', ,','  
     ','      |                                                  |      ','    
----------------------------------------------------------------------------

Monday, 10 May 1993 18:39:54 UTC+1 - D.Gr...@lut.ac.uk:
Um... We don't actually know for absolute certain whether or not our
_closest_ star has any habitable planets (other than our  own, that
is!).  It might pose a wee bit of a problem to analyse other stars. 
Hell, if stars 50ly away do have habitable planets, they might just have
been colonised anyway. Keep an eye out for tree-of-life root! :)
(obscure reference to Niven's "Protector")
----------------------------------------------------------------------------

Wednesday, 12 May 1993 04:51:38 UTC+1 - Joseph Hall:
In article <C6t5B...@dcs.glasgow.ac.uk <>> fras...@dcs.glasgow.ac.uk <> (David K Fraser) writes:
>c...@cs.anu.edu.au <> (Chris Johnson) writes:
>
>>there were a couple of book s published on habitable planets.:
>>one was
>>        Stephen Dole and I. Asimov,
>>title was Planets for Man (I think??)
There's a book titled "Habitable Planets for Man."  When I was at
Clarion in 1985, one of us brought a copy--I think it was Geoff Landis.
At that time it was looong out of print (may well still be) and could
be found only at a considerable premium at cons and trade shows.
Many of us left with photocopies of it, which would probably be
considered "fair use" since it simply is not available, even in
most libraries.  If I ever actually use it I may try to find out
who to send a CCC payment to.

I don't have the book handy and don't remember the author's name,
alas.

There are probably some Fred Hoyle texts that writers would find
useful.  His writing (at least his nonfiction) tends to be
extremely lucid.


>>published in late 1960s.
>
>John Cramer, a little known physicist-turned-hard-sf-author, has written
>a hypercard stack called "Sol's Neighbours". It's floating around on
>shareware, and I think it has the information that was being asked for.
Interesting you should mention him.  I ran across his killer
periodic table stack a few years ago.  It mentioned his book
"Twistor," which I then searched maybe 3-4 years for until finding
a new copy in a bookstore a few months ago.  Not exactly the Holy
Grail of SF but entertaining nonetheless.  Sort of a restrained
Harry Harrison romp.


-- 
--------------------- Nobody MEANS to live in New Jersey --------------------
Joseph Nathan Hall               "The ones that miss you, they's just purty."
Software Systems Engineer                  GORCA Systems Inc. (on assignment)
Internet: jnh...@sat.mot.com <>                            Voice: (602) 732-3194
----------------------------------------------------------------------------

Wednesday, 12 May 1993 11:43:22 UTC+1 - Dave Garnett:
|> There's a book titled "Habitable Planets for Man."  When I was at
|> Clarion in 1985, one of us brought a copy--I think it was Geoff Landis.
|> At that time it was looong out of print (may well still be) and could
|> I don't have the book handy and don't remember the author's name,
|> alas.


 Author:         Dole, S.H.
 Title:          Habitable planets for man/ S.H. Dole
                 New York, 1964
 


|> --------------------- Nobody MEANS to live in New Jersey --------------------
|> Joseph Nathan Hall               "The ones that miss you, they's just purty."
|> Software Systems Engineer                  GORCA Systems Inc. (on assignment)
|> Internet: jnh...@sat.mot.com <>                            Voice: (602) 732-3194
-- 
Dave Garnett     | d...@cam-orl.co.uk <>
                 | Olivetti Research, Cambridge, England CB2 1QA.
                 | (voice) +44 223 343000  (fax) +44 223 313542
----------------------------------------------------------------------------

Wednesday, 12 May 1993 19:49:53 UTC+1 - Robert Hearn:
In article <1993May10.1...@lut.ac.uk <>>, D.Gr...@lut.ac.uk <> wrote:
> 
> Um... We don't actually know for absolute certain whether or not our
> _closest_ star has any habitable planets (other than our  own, that
> is!).  It might pose a wee bit of a problem to analyse other stars. 
Yes, but recent and upcoming astronomical advances (Keck, Hubble, CCD,
adaptive optics) will likely enable detection of Earth-sized planets
around nearby stars within the next decade.  In particular, effective
exposure times on the order of days or weeks are possible with current
CCD technology.  Combine that with good seeing, adaptive optics, and
a big telescope, and we're talking magnitude 30+.  I figure a
Jupiter-sized planet at tau Ceti would be around mag. 27-28.

I believe a dust belt has already been detected around epsilon Eridani.


Bob Hearn
Spartacus Software

Opinions expressed here are those of my employer, since that's me.
----------------------------------------------------------------------------

Thursday, 13 May 1993 22:16:04 UTC+1 - John Redford:
In article <C6t9w...@brunel.ac.uk <>> mt9...@brunel.ac.uk <> (Del Cotter) writes:

   from:


   Martyn Fogg
   "An Estimate of the Prevalence of Biocompatible and Habitable Planets"
   J. Brit. Interplanetary Soc. _45_, 3-12 (1992)

   Where P(hp) = probability of the occurence of a habitable planet
   Where P(hp) = probability of the occurence of a biocompatible planet

   Star                        Dist.        Spect.        Mass        P(hp)        P(bp)
                           /ly        Type        /Solar        /%        /%

   alpha Centauri A        4.38        G2V        1.1        7.8        44
   alpha Centauri B        4.38        K6V        0.89        4.4        38
   epsilon Eridani        10.69        K2V        0.8        0.6        34
   ...
Two significant figures for the probabilities?  That's rather bold.  I
doubt if we can even estimate the order of magnitude of such numbers,
much less give them to within 1%.  The last that I had heard was that
no one has even detected Jupiter-size planets around other stars, much
less bio-compatible ones.  One can go by the Principle of
Mediocrity and say that stars similar to the sun ought to have planets
like ours, but there really isn't any data.


--
/jlr (John Redford, jred...@bbn.com <>)
----------------------------------------------------------------------------

Friday, 14 May 1993 19:18:56 UTC+1 - ste...@arc.ug.eds.com:
> Arild Toerum (art@tigern.uucp) wrote:
>  Could somebody list a number of relately proximate stars which may
>  possibly have habitable planets. I am thinking of stars within a range of
>  50 or so lightyears from Earth, and with possible planets where human
>  beings could surve. Thanx in advance!
This is a subset from the Gliese star catalogue, of suitable spectral classes

beta hyi        eta cas A        eta cas B        tau cet                HR 753 A 
82 eri                Grm 1618        alpha cen A        alpha cen B        HR 5568 B 
36 oph A        70 Oph B        sigma dra        delta pav        61 cyg A 
eps indi        zeta Tuc        pi3 Ori                beta CVn        beta com 
61 Vir                chi dra                BD +63 238        gamma lep A        CD -5 1844
BD +36 1979 A        CD -19 3243 A        CD -32 8179 A        BD +49 2079        beta Vir 
CD -26 8883        BD +34 2342        41 Arae A        CD -34 11626 B  BD +2 3382 
gamma pav        zeta tuc        beta hyi        BD +61 366 

(the sub-set is due to the fact that I ran a planet generation simulator & 
some rought climate modelling on the resulting planets & these are the systems
that passed that sieve.  It ignores orbital interactions between multiple 
systems, & has no infomation on system age but skips systems with white dwarf 
stars)
----------------------------------------------------------------------------

Friday, 14 May 1993 23:40:23 UTC+1 - Del Cotter:
jred...@centaur.bbn.com <> (John Redford) writes:

>Two significant figures for the probabilities?  That's rather bold. 
   Star                        Dist.        Spect.        Mass        P(hp)        P(bp)

                           /ly        Type        /Solar        /%        /%
   alpha Centauri A        4.38        G2V        1.1        ?        ?
   alpha Centauri B        4.38        K6V        0.89        ?        ?
   epsilon Eridani        10.69        K2V        0.8        ?        ?

Happy?

It's getting late here; I may have more to say about these pompous remarks
tomorrow.  In the meantime why don't you read the paper and find out
what P(hp) means.  Clue: it's *not* the probability that Alpha Centauri
A has a habitable planet, because as you so kindly inform us defectives,
this is not currently knowable to *any* degree of precision whatsoever.

The original poster asked for candidates, and I thought it might be nice
to supply a list including rankings according to one particular model.
Remind me to save myself the RSI next time.

(In a bad mood tonight)

-- 
 ',' ' ',','  |                                                |  ',' ' ',','
   ', ,','    |      Del Cotter      mt9...@brunel.ac.uk <>      |    ', ,','  
     ','      |                                                |      ','    
----------------------------------------------------------------------------

Saturday, 15 May 1993 10:27:05 UTC+1 - Stuart C. Squibb:
In article <1993May14...@arc.ug.eds.com <>> ste...@arc.ug.eds.com <> writes:

>(the sub-set is due to the fact that I ran a planet generation simulator & 
>some rought climate modelling on the resulting planets & these are the systems
>that passed that sieve.  It ignores orbital interactions between multiple 
>systems, & has no infomation on system age but skips systems with white dwarf 
>stars)
Planet generation simulator? Is this freeware/shareware/PD? If not, how much
does it cost? Please e-mail me if possible.

Thanks,
Stuart

-- 
|Stuart Squibb                   |e-mail: stu_s...@cix.compulink.co.uk <>      |
|I.T. Systems Administrator      |        s...@vectis.demon.co.uk <> (preferred)  |
|Isle of Wight Health Commission |--------------------------------------------| |
|PO30 3ED, England.              |"Yield to temptation; it may not pass your  |
|+44-983-526011 Ext. 242         | way again."  -- Lazurus Long               |
----------------------------------------------------------------------------

Saturday, 15 May 1993 13:26:26 UTC+1 - ste...@arc.ug.eds.com:
> Arild Toerum (art@tigern.uucp) wrote:
>  Could somebody list a number of relately proximate stars which may
>  possibly have habitable planets. I am thinking of stars within a range of
>  50 or so lightyears from Earth, and with possible planets where human
>  beings could surve. Thanx in advance!
There's been some talk about catalogue like Gliese's (of stars within 25pc)
& more recent verions in sci.astro recently.  I can't recall if anyone 
mentioned an ftp site for it, though.  Failing that, the rolegame "Traveller 2300"
excerpts most of the spectral & coordinate (w/1 lightyear granualrity in
cartesian coordinates) data from Gliese in a pamphlet & map of the neighbourhood
out to about 50 ly.
----------------------------------------------------------------------------

Saturday, 15 May 1993 15:04:52 UTC+1 - Bruce d. Scott:
> There's been some talk about catalogue like Gliese's (of stars within 25pc)
This is the Wooley catalogue. It is at the Nasa Ames archive site.
Read more in the sci.space/sci.astro FAQ, posted monthly.
-- 
Gruss,
Dr Bruce Scott                             The deadliest bullshit is
Max-Planck-Institut fuer Plasmaphysik       odorless and transparent
bds at spl6n1.aug.ipp-garching.mpg.de <http://spl6n1.aug.ipp-garching.mpg.de>                 -- W Gibson
----------------------------------------------------------------------------

Saturday, 15 May 1993 15:56:52 UTC+1 - James Davis Nicoll:
- show quoted text -In article <1993May15...@arc.ug.eds.com <>> ste...@arc.ug.eds.com <> writes:
>> Arild Toerum (art@tigern.uucp) wrote:
>>  Could somebody list a number of relately proximate stars which may
>>  possibly have habitable planets. I am thinking of stars within a range of
>>  50 or so lightyears from Earth, and with possible planets where human
>>  beings could surve. Thanx in advance!
>
>There's been some talk about catalogue like Gliese's (of stars within 25pc)
>& more recent verions in sci.astro recently.  I can't recall if anyone 
>mentioned an ftp site for it, though.  Failing that, the rolegame "Traveller 
>2300" excerpts most of the spectral & coordinate (w/1 lightyear granualrity in
>cartesian coordinates) data from Gliese in a pamphlet & map of the 
>neighbourhood out to about 50 ly.
        Note that the 2300 cataloguemay undercount red dwarfs: the
further one is from (0,0,0), the greater the ratio of bright to dim
stars is  and the density of stars overall goes down.

        Since red dwarfs are thought to be unlikely havens for life-bearing
worlds, this may not be important to this discussion.  

        Although a 2/3 tidal lock shouldn't be too bad on a short
period world, and there're always ocean-worlds like Europa to think
about. 

                                                        James Nicoll
----------------------------------------------------------------------------

Sunday, 16 May 1993 00:15:03 UTC+1 - Paul Dietz:
In article <1993May15.1...@julian.uwo.ca <>> jdni...@prism.ccs.uwo.ca <> (James Davis Nicoll) writes:

>        Since red dwarfs are thought to be unlikely havens for life-bearing
> worlds, this may not be important to this discussion.  
>
>        Although a 2/3 tidal lock shouldn't be too bad on a short
> period world, and there're always ocean-worlds like Europa to think
> about. 

Another reason, besides tidal locking, to worry about the feasibility
of lifebearing planets around red dwarfs is the problem of impacts.

Objects hitting a planet will do so at on the order of the planet's
orbital velocity.  A planet in the habitable zone around a small star
will be at a much deeper gravitational potential than around a larger
star (because the star's luminosity decreases much faster than its
mass).  Therefore, impacts will be at higher energy.  Around a star of
1/2 solar mass, for example, impacts on a habitable planet would be at
several time the speed of impacts on earth.  Too much energy input in
impacts could erode atmospheres or prevent delivery of volatiles.

        Paul F. Dietz
        di...@cs.rochester.edu <>
----------------------------------------------------------------------------

Sunday, 16 May 1993 01:40:59 UTC+1 - Ross Smith:
In article <1993May12....@sat.mot.com <>> jnh...@sat.mot.com <> (Joseph Hall) writes:
>In article <C6t5B...@dcs.glasgow.ac.uk <>> fras...@dcs.glasgow.ac.uk <> (David K Fraser) writes:
>>c...@cs.anu.edu.au <> (Chris Johnson) writes:
>>
>>>there were a couple of book s published on habitable planets.:
>>>one was
>>>     Stephen Dole and I. Asimov,
>>>title was Planets for Man (I think??)
>
>There's a book titled "Habitable Planets for Man."  When I was at
>Clarion in 1985, one of us brought a copy--I think it was Geoff Landis.
>At that time it was looong out of print (may well still be) and could
>be found only at a considerable premium at cons and trade shows.
>Many of us left with photocopies of it, which would probably be
>considered "fair use" since it simply is not available, even in
>most libraries.  If I ever actually use it I may try to find out
>who to send a CCC payment to.
>
>I don't have the book handy and don't remember the author's name,
>alas.
There are actually two books being slightly confused here. Stephen Dole
wrote `Planets for Man', a serious technical treatment of the subject.
Later, he and Isaac Asimov collaborated on `Habitable Planets for Man',
a popular treatment of the subject, covering the same ground but in much
less detail.

--
... Ross Smith (Wanganui, NZ) ............ al...@acheron.amigans.gen.nz <> ...
"Look, we're travelling faster than the speed of light.  That means, by the
time we see something, we've already passed through it.  Even with an IQ of
6000, it's still brown trousers time." (Holly)
----------------------------------------------------------------------------

Monday, 17 May 1993 11:45:26 UTC+1 - ste...@arc.ug.eds.com:
- show quoted text -s...@vectis.demon.co.uk <> ("Stuart C. Squibb") writes:
> In article <1993May14...@arc.ug.eds.com <>> ste...@arc.ug.eds.com <> writes:
> 
>>(the sub-set is due to the fact that I ran a planet generation simulator & 
>>some rought climate modelling on the resulting planets & these are the systems
>>that passed that sieve.  It ignores orbital interactions between multiple 
>>systems, & has no infomation on system age but skips systems with white dwarf 
>>stars)
> 
> Planet generation simulator? Is this freeware/shareware/PD? If not, how much
> does it cost? Please e-mail me if possible.
> 
> Thanks,
> Stuart
> 
> -- 
> |Stuart Squibb                   |e-mail: stu_s...@cix.compulink.co.uk <>      |
> |I.T. Systems Administrator      |        s...@vectis.demon.co.uk <> (preferred)  |
> |Isle of Wight Health Commission |--------------------------------------------| |
> |PO30 3ED, England.              |"Yield to temptation; it may not pass your  |
> |+44-983-526011 Ext. 242         | way again."  -- Lazurus Long               |

The program is one I wrote based on Dole's original paper in _Icarus_ in the 
late '60s.  I'm afraid I don't have it available in machine readable form here 
(it lives on my PC at home, but my e-mail address is at work) : this is partly 
to avoid any contention about whether it is company property as written on 
their equipment...

It appeared in the gaming magazine _White Dwarf_ issue 57 (which is about 9 
years ago now & probably isn't much help) written in Basic.

The algorithm is roughly

Over cells at 0.1 AU separation up to about 50 AU, representing rings of 
material in the protoplanetary disk, set up inital gas & dust densities

Introduce a small particle which will  accrete all the material whose orbit it 
crosses + band of width (apse length)*(planet mass/star mass)**0.25 on either 
side.  If the mass is large enough to hold helium, accrete the gas too.  keep 
iterating this until the mass stabilises.

Add another particle.  If two particle orbits overlap in radius, then collide 
them, conserving angular momentum & let the accumulation accrete more material 
until it stabilises.

Continue until the dust is exhausted.

Unfortunately I don't have the magic numbers to hand.  Since this has
caused some interest, I'll look the code out.
----------------------------------------------------------------------------

Monday, 17 May 1993 17:39:44 UTC+1 - James Davis Nicoll:
In article <1993May15.2...@cs.rochester.edu <>> di...@cs.rochester.edu <> (Paul Dietz) writes:
>
>Another reason, besides tidal locking, to worry about the feasibility
>of lifebearing planets around red dwarfs is the problem of impacts.
>
>Objects hitting a planet will do so at on the order of the planet's
>orbital velocity.  A planet in the habitable zone around a small star
>will be at a much deeper gravitational potential than around a larger
>star (because the star's luminosity decreases much faster than its
>mass).  Therefore, impacts will be at higher energy.  Around a star of
>1/2 solar mass, for example, impacts on a habitable planet would be at
>several time the speed of impacts on earth.  Too much energy input in
>impacts could erode atmospheres or prevent delivery of volatiles.
        I hate to sound like an innumerate ninny, but could you show
your calculations for this? I can't get the numbers to come out right,
and I'd like to see where my error is.

                                                        James Nicoll
----------------------------------------------------------------------------

Monday, 17 May 1993 18:13:04 UTC+1 - Paul Dietz:
In article <1993May17.1...@julian.uwo.ca <>> jdni...@prism.ccs.uwo.ca <> (James Davis Nicoll) writes:


>> mass).  Therefore, impacts will be at higher energy.  Around a star of
>> 1/2 solar mass, for example, impacts on a habitable planet would be at
>> several time the speed of impacts on earth.
> I hate to sound like an innumerate ninny, but could you show

> your calculations for this? I can't get the numbers to come out right,
> and I'd like to see where my error is.

My error, not yours.

Consider a star of mass M and luminosity L (where M_sol = L_sol = 1).
If a planet receives the same energy as the earth, then the orbital
radius r is proportional to L^{1/2}.  The orbital velocity is then
proportional to M^{1/2} L^{-1/4}.

Plugging in some numbers gives:

        Class        M        L        V (earth = 1)
        ------------------------------------
        M0        .5        .0589          1.43
        M2        .4        .0331          1.48
        M4        .28        .0123     1.59
        M6        .126        .00195          1.68

Impact *energies* are between 2 and 3 times that on earth,
not impact speed.

        Paul F. Dietz
        di...@cs.rochester.edu <>
----------------------------------------------------------------------------

Tuesday, 18 May 1993 00:10:35 UTC+1 - James Davis Nicoll:
In article <1993May17.1...@cs.rochester.edu <>> di...@cs.rochester.edu <> (Paul Dietz) writes:
>
>My error, not yours.
>
>Consider a star of mass M and luminosity L (where M_sol = L_sol = 1).
>If a planet receives the same energy as the earth, then the orbital
>radius r is proportional to L^{1/2}.  The orbital velocity is then
>proportional to M^{1/2} L^{-1/4}.
>
>Plugging in some numbers gives:
>
>        Class        M        L        V (earth = 1)
>        ------------------------------------
>        M0        .5        .0589          1.43
>        M2        .4        .0331          1.48
>        M4        .28        .0123     1.59
>        M6        .126        .00195          1.68
>
>Impact *energies* are between 2 and 3 times that on earth,
>not impact speed.
        Hmmm. V for Venus is about  1.2, and Mercury has a V of
about 1.6. That would seem to indicate planets *do* accrete under
those conditions (Not that you said they didn't). I think that
Mercury has the highest value for V in the Solar System.  Metis
is V = 1, and all the other close Gas Giant moons have lower
values of V.

        I'd wave Metis' density as proof high volatile content
is not closely tied to V, except I don't have those figures. Pooh.

        Mercury gets impacted at about 10x Mercurian escape velocity,
if I haven't messed up. I guess any ejecta travelling faster than
Ev(mercury) tends to remain in a similar orbit to Mercury and
impacts again later. Would that work to keep  materials on a world?

        Um. More later. I want to think about this...

        Gas giant escape velocities  are (I think) greater than
their values for V...

                                                        James Nicoll
----------------------------------------------------------------------------

Tuesday, 18 May 1993 01:49:26 UTC+1 - Paul Dietz:
In article <1993May17.2...@julian.uwo.ca <>> jdni...@prism.ccs.uwo.ca <> (James Davis Nicoll) writes:

>        Hmmm. V for Venus is about  1.2, and Mercury has a V of
> about 1.6. That would seem to indicate planets *do* accrete under
> those conditions (Not that you said they didn't). I think that
> Mercury has the highest value for V in the Solar System.
...
>        Mercury gets impacted at about 10x Mercurian escape velocity,
> if I haven't messed up. I guess any ejecta travelling faster than
> Ev(mercury) tends to remain in a similar orbit to Mercury and
> impacts again later. Would that work to keep  materials on a world?

It has been conjectured that Mercury damn near didn't survive.  It has
an anomalously high density; its core is proportionally much larger
than Venus's or Earth's.  It is thought that a large head-on collision
in the early solar system blew most the Mercury's (and the impactor's)
crust and mantle into solar orbit, where the Poynting-Robertson effect
caused much of it to spiral into the sun before it could reaccrete.

        Paul F. Dietz
        di...@cs.rochester.edu <>
----------------------------------------------------------------------------

Tuesday, 18 May 1993 10:23:30 UTC+1 - ste...@arc.ug.eds.com:
References to bear in mind are
Dole, S.H. Icarus _13_ 494 "Computer simulation of the formation of planetary 
                            systems" 
Hart, M.   Icarus _35_  23 "Evolution of the atmosphere of the Earth"
           Icarus _37_ 351 "Habitable Zones about Main sequence Stars"
Fogg, M.   JBIS   _38_ 501 "Extrasolar Planetary Systems: a microcomputer
                            simulation".

Rather than have to code & debug the program again here, I'll outline what I 
did based on Dole's paper (and his "Habitable Planets for Man", publ. Elsvier 
1974, I believe).  My scalings with star mass, & planet mass are my own, and 
differ from those of Fogg, for example.  The climate modelling is based partly 
on Hart's papers (I've not done anything with the atmospheric evolution, since 
that model allows things only within a couple of % of Earthlike).

1) Establish size of protoplanetary disk.

If star mas is MS in solar units, then luminosity in solar unis=ts LS is

MS^4 (MS > 0.4) otherwise 0.23*(MS^2.3)

Rock will volatilise at 3*(LS^0.5) AU.  From here up to ~50AU the mass of dust 
in a band 0.1 AU wide is given by the following

    let a1 = radius of band/MS^(1/3)
    mass in band = 1.5*(a1^2)*exp(-5*(a1^(1/3))) dust (earth masses)
    usually 25 times this value works for the gas
    

2) Inject a nucleus at some radius R where there is still dust, with a chosen
orbital eccentricity e (0.35 was used in the original).  The periastron is at
Rp = R(1-e), apastron at R(1+e).  All dust still within these radii acculumate 
on the nucleus.  (R = semi-major axis of ellipse).

The critical mass for gas accumulation is 0.12*(Rp^-0.75)*(LS^0.375).  If this 
much mass has been accumulated, all gas ramaining between RP and RA is also
accumulated.

The gravity of the body extends its range roughly 

0.1*((mass of body in earths/MS)^(0.25)) beyond the apsides.

Keep iterating until this mass stabilises.  Then add another.

3) Collisions occur if two bodies can reach the same radius.  Sum the angular 
momenta 

    mass * ((semi-major axis * (1-e^2))^0.5)

and masses.  The new eccentricity I took randomly over 0-smaller of the two, 
and thus derived semi-major axis of composite as

    R = (total ang-mom/total mass)^2 /(1-e(new)^2)

and the new composite gets to accrete any gas & dust available to its new 
orbit and mass.

Repeat until no dust is left.

        *                *                *                *            *

approximate climate modelling:-

1) Assume earth-like greenhouse effect:  Average temperature of 0-dimensional 
model is 288*(LS^0.25)/(semi-major axis of orbit ^ 0.5)

2) Assume temperature dependent greenhouse effect.  Assume some fraction of 
the planet's surface covered by water, say FW (I used 0.7 M/(R^2)  M,R in 
Earth =1 units).  The Black-body temperature is 0.9680555 of that from stage 1.
Gravity is G = M/(R^2).  base atmospheric pressure = G^2 (Assumption mass of 
volatiles proportional to mass of body; thus per unit area the amount of water 
or atmosphere goes as mass/area)

Iterate from the temperature of stage 1.  Call temperature this iteration T.

Quantity of water vapour = exp(0.698*(T-288)) * FW/(0.7*G) excess
(maximum = 1597900*G*FW = 100% cloud)
Cloud cover, FC  = 0.674286 * FW * Quantity of vater vapour
Atmospheric pressure = G^2+0.00244*G*(quantity of water vapour - 1)
Fraction of surface glaciated, FI  = ((328-T)/70) ^ 5 ; limitied between 0&1

Albedo = 0.52*FC+(1-FC)(0.7*FI + (1-FI)*(FW*0.04+(1-FW)*0.14)))

Effective temperature = Black-body temperature*(1-Albedo)^).25
Water greenhouse = Quantity of water vapour*pressure*(288/T)^0.5
CO2 greenhouse = 4.60388*pressure*(288/T)^0.5
Tau = 2.34*(Water greenhouse)^0.5 = 0.15*(CO2 greenhouse)^0.5

Temperature with this greenhouse value Tg is given by

Effective temperature * (1 + 0.43 * ((1+0.75*Tau)^0.25))

Set T to 0.9*T+0.1*Tg and continue the iteration until T stabilises.

            *                    *                    *                    *

The following is based on an algorithm by Henderson-Sellers in an introductory 
textbook to climate modelling, the reference to which I don't have to hand.  
I've not worked on this for a while, but it looks like I started, but didn't 
finish, attempting to model seasonal effects.

        implicit real*8 (a-h,o-z)
        character*16 name
        dimension range(10)
c
 10        continue
C read planet radius (earths), nominal temperature (k), dummy value, dummy 
C value, orbital radius(AU), star mass (solar units), orbital eccentricity & 
C fraction of surface covered with water
        read(1,*,end=999) rp,tnom,rlam,phi,starr,starm,eps,fw
        read(1,9000) name
 9000        format(a16)
c
        write(2,9100) name
        write(6,9100) name
 9100        format(//,5x,a21)
c
        q = tnom/288.0d0
        tnom = tnom -273.0d0
        q = 342.5 * q * q * q * q
        a = 204.0d0
        b = 2.17d0
        rk = 3.8d0/(rp*rp)
        c = 1.63d0 * starr*dsqrt(starr/starm)
        t0 = -13.0d0*fw
        t0 = -10.0d0*fw/0.7d0
        a0 = 0.7
        a1 = 0.4
c
        pi = 4.0*datan(1.0d0)
        rlhs = (b+rk)*t0 + a*(1.0d0 + (rk/b))
        rlhs = ((rlhs/q)  - rk*a1/b)*(pi/2.0d0)
        c1 = (a0+a1)
        c2 = (a0-a1)*rk/b
c
        halfpi = pi/2.0d0
        f0 = c1 - rlhs
        fh = halfpi*c2 - rlhs
c
        s = -(c1 - dsqrt(c1*c1+16.0d0*c2*c2))/(4.0d0*c2)
        th = 0.0d0
        if(s.le.1.0d0) th = dasin(s)
           fth = c1*dcos(th) + c2*(th+dsin(th)*dcos(th))
     &                - rlhs
c
        if (fh .ge. 0.0d0) then
                theta0 = halfpi
                goto 20
        else
                if(f0 .le. 0.0) then
                        if(fth .gt. 0.0d0) goto 40
                        theta0 = 0.0d0
                        goto 20
                endif
        endif
c
 40        continue
        fold = fh
        theta0 = halfpi
        do k = 1,50
           theta = halfpi*float(50-k)*0.02d0
           fth = c1*dcos(theta) + c2*(theta+dsin(theta)*dcos(theta))
     &                - rlhs
                write(6,5000) theta,fth
 5000        format(2(2x,f10.4))
           if( (fth*fold.lt.0.0d0).and.(fth.gt.0.0d0)) then
                theta0 = theta
                goto 60
           endif
           fold = fth
        enddo
 20        continue
        write(6,9001)
        write(2,9001)
 9001        format(' defaulted')
        goto 100
c
 60        continue
           fth = c1*dcos(theta0) + c2*(theta0+dsin(theta0)*dcos(theta0))
     &                - rlhs
        fpth = -c1*dsin(theta0) + c2*(1.0d0+dcos(2.0d0*theta0))
        dth = -fth/fpth
c
        theta0 = theta0+dth
        write(6,9999) theta0
c
        if( dabs(dth) .gt. 0.0001) goto 60
c
 100        continue
        write(6,9999) theta0
 9999        format(1x,f10.3)
        if(theta0 .gt. pi/2.0d0) theta0 = pi/2.0d0
        if(theta0 .lt. 0.0d0) theta0 = 0.0d0
        thdeg = theta0*180.0d0/pi
c
        write(2,9200) thdeg,tnom
 9200        format(' Ice above latitude ',f5.1,' Nominal temp = ',f6.1)
c
        sigma = a1 + 2.0d0*(a0-a1)*(theta0+dsin(theta0)*dcos(theta0))/pi
        z = (q*sigma-a)/b
        xy = 2.0d0*eps*q*sigma/(b*b+c*c)
        x = xy*c
        y = xy*b
c
        write(2,9300) z,x,y
 9300        format(' T_bar = ',f6.2,' + ',f6.2,'sin(t-\) + ',f6.2,'cos(t-\)')
c
        z1 = 4.0d0*q/(pi*(b+rk))
        z2 = ( -(rk*q*sigma/b) + a*(1.0d0+(rk/b)) )/(b+rk)
c
        write(2,9400) z1, z2
 9400        format(' annual mean = ',f6.2,'*a*cos - ',f6.2)
        tx = z1*(a1+a0)*dcos(theta0)*0.5d0 - z2
        write(2,9410) tx, t0
 9410        format(' t(ice) = ',f6.2,' t_crit = ',f6.2)
        do k = 1, 10
         ax = a0
         if (10*(k-1) .gt. thdeg) ax = a1
         range(k) = z1*ax*cosd(10.0*float(k-1)) - z2
        end do
        write (2,9411) (range(k),k=1,10)
 9411        format(10(2x,f5.1))
c
        del = ((b+rk)*(b+rk)+c*c)
        fac = 2.0d0*eps*q/del
        d2 = (b*b + c*c)
        rksc = -rk*sigma*c
c
        x1 = 4.0d0*fac/pi
        y1 = x1 * (b+rk)
        x1 = x1 * c
        x2 = -fac*rksc*(c+b+rk)/d2
c
        write(2,9500) x1, x2
 9500        format(' sin(t-\) coeff= ',f6.2,'*a*cos + ',f6.2)
c
c
        y2 = -fac*rksc*(-c+b+rk)/d2
c
        write(2,9600) y1, y2
 9600        format(' cos(t-\) coeff= ',f6.2,'*a*cos + ',f6.2)
c
        goto 10
 999        continue
        stop ' '
        end
----------------------------------------------------------------------------

Tuesday, 18 May 1993 13:49:45 UTC+1 - Bruce d. Scott:
Paul Dietz posted this nice summary:
"It has been conjectured that Mercury damn near didn't survive.  It has
an anomalously high density; its core is proportionally much larger
than Venus's or Earth's.  It is thought that a large head-on collision
in the early solar system blew most the Mercury's (and the impactor's)
crust and mantle into solar orbit, where the Poynting-Robertson effect
caused much of it to spiral into the sun before it could reaccrete."

I just wanted to add some details:

A set of computations were done by Benz and collaborators (Icarus, sometime
during 1989) to see whether Mercury's unusual composition could have been
caused solely by collision. They had just provided plausible scenarios
for the origin of the Moon by impact (Icarus, vol 81, p 113, 1989), and
used the same numerical techniques for Mercury. Two protoplanets with
'chondritic composition' (the usual 'primordial earth' composition, taken
from some wighted average over all the chondritic meteorite types, so
named for the small 'chondrules': small rounded bodies less than 1 mm in
size, which are of a certain type of rock known as 'olivine') are taken
as given and made to impact at a certain relative velocity. With a proto-
Mercury of 2.2 present-Mercury masses, and impactor of similar size, and
a relative velocity of 35 km/sec, they were able to reproduce in rough
outline (the Fe/rock ratio) the present Mercury's composition. This
figure of 35 km/sec is between orbital and escape velocity at 0.4 AU.
It is plausible as well that the high eccentricity and inclination of
Mercury's orbit could have been caused by the same collision.
-- 
Gruss,
Dr Bruce Scott                             The deadliest bullshit is
Max-Planck-Institut fuer Plasmaphysik       odorless and transparent
bds at spl6n1.aug.ipp-garching.mpg.de <http://spl6n1.aug.ipp-garching.mpg.de>                 -- W Gibson
----------------------------------------------------------------------------

Tuesday, 18 May 1993 16:08:36 UTC+1 - S. Arrowsmith:
In article <1993May17.2...@julian.uwo.ca <>> jdni...@prism.ccs.uwo.ca <> (James Davis Nicoll) writes:
>        Mercury gets impacted at about 10x Mercurian escape velocity,
>if I haven't messed up. I guess any ejecta travelling faster than
>Ev(mercury) tends to remain in a similar orbit to Mercury and
>impacts again later. Would that work to keep  materials on a world?
>
Well, I seem to remember that Titan's atmosphere does something
entertaining in a  similar vein to this (ie there's a ring of thin
"atmosphere" which it accumulates and loses on its orbit.)  However,
whether the same thing would happen for more dense matter in a much
more serious gravitational well, I wouldn't like to speculate on
without much more calculation than I've got time for....
--
\S
SA...@phx.cam.ac.uk <> | "Internet is so big, so powerful and pointless that for
        ___         |  some people it is a complete substitute for life."
        \X/         |     -- Andrew Brown, The Independent
----------------------------------------------------------------------------

Tuesday, 18 May 1993 16:56:40 UTC+1 - Travis Corcoran:
  Well, I seem to remember that Titan's atmosphere does something
   entertaining in a  similar vein to this (ie there's a ring of thin
   "atmosphere" which it accumulates and loses on its orbit.)  However,
As I recall, there's a volcano which vents gas at above escape
velocity.  The gas forms a ring in orbit.  As the moon (I also think
its Titan, but am not 100% sure) orbits, it sweeps up the ring.
Pretty neat, in my book.

---
Travis Corcoran                      tcor...@sunlab.cit.cornell.edu <>
'This is not an assault' - FBI loudspeaker announcement as tanks broke down
the walls of the Davidian compound under sniper and helicopter cover.
----------------------------------------------------------------------------

Thursday, 20 May 1993 19:14:20 UTC+1 - ste...@arc.ug.eds.com:
The following was posted on rec.games.frp.misc just t'other day,
which does all I've been talking about.
Thanks to Larry Smith (sm...@ctron.com <>) who uploaded it


I dunno if this is what you are looking for, but it does a similar job, but
not for a particular game.  Accrete was written to simulate a spinning cloud
of dust collapsing into a solar system.  It generates a description of the
entire system and each planet, though it generates no maps.  I pulled it from
the "Actual" simulation archive (which is a whole story itself, but for later).

Here it is:

From: Matt Burdick <burdick%hpind...@relay.cs.net <>>
Subject: C starform code

OK.  I've ported the code to C and cleaned it up a bit.  Sorry for any
'pascalisms' that may still be in it.  I still have to get it to generate
moons for the planets so that I can find out how much the planet's daily
rotation is slowed by them.

Please let me know if anyone finds any problems in the code or the
algorithms.  I can be reached at burdic...@hplabs.hp.com <>

Here's the code in shar'ed form:


# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
#
# Wrapped by Matt Burdick <burdick@hpindl1> on Wed Sep 14 17:56:49 1988
#                Matt Burdick
#                burdic...@hplabs.hp.com <>
#
# This archive contains:
#        accrete.c        display.c        enviro.c        main.c                
#        utils.c                const.h                structs.h        
#

LANG=""; export LANG

echo x - accrete.c
cat >accrete.c <<'@EOF'
/*----------------------------------------------------------------------*/
/*                           BIBLIOGRAPHY                               */
/*  Dole, Stephen H.  "Formation of Planetary Systems by Aggregation:   */
/*      a Computer Simulation"  October 1969,  Rand Corporation Paper   */
/*        P-4226.                                                                */
/*----------------------------------------------------------------------*/

typedef struct dust_bands_record  *dust_pointer;
typedef struct dust_bands_record {
          double inner_edge;
          double outer_edge;
          int dust_present;
          int gas_present;
          dust_pointer next_band;
     } dust_bands;

/* A few variables global to the entire program:                */
extern planet_pointer planet_head;

/* Now for some variables global to the accretion process:      */
int dust_left;
double r_inner, r_outer, reduced_mass, dust_density, cloud_eccentricity;
dust_pointer dust_head;


void set_initial_conditions(inner_limit_of_dust, outer_limit_of_dust)
double inner_limit_of_dust, outer_limit_of_dust;
{
     dust_head = (dust_bands *)malloc(sizeof(dust_bands));
     planet_head = NULL;
     dust_head->next_band = NULL;
     dust_head->outer_edge = outer_limit_of_dust;
     dust_head->inner_edge = inner_limit_of_dust;
     dust_head->dust_present = TRUE;
     dust_head->gas_present = TRUE;
     dust_left = TRUE;
     cloud_eccentricity = 0.2;
}

double stellar_dust_limit(stellar_mass_ratio)
double stellar_mass_ratio; 
{
     return(200.0 * pow(stellar_mass_ratio,(1.0 / 3.0)));
}

double innermost_planet(stellar_mass_ratio)
double stellar_mass_ratio; 
{
     return(0.3 * pow(stellar_mass_ratio,(1.0 / 3.0)));
}

double outermost_planet(stellar_mass_ratio)
double stellar_mass_ratio; 
{
     return(50.0 * pow(stellar_mass_ratio,(1.0 / 3.0)));
}

double inner_effect_limit(a, e, mass)
double a, e, mass;
{
     return (a * (1.0 - e) * (1.0 - mass) / (1.0 + cloud_eccentricity));
}

double outer_effect_limit(a, e, mass)
double a, e, mass;
{
     return (a * (1.0 + e) * (1.0 + reduced_mass) / (1.0 - cloud_eccentricity));
}

int dust_available(inside_range, outside_range)
double inside_range, outside_range;
{
     dust_pointer current_dust_band;
     int dust_here;
     
     current_dust_band = dust_head;
     while ((current_dust_band != NULL)
            && (current_dust_band->outer_edge < inside_range))
          current_dust_band = current_dust_band->next_band;
     if (current_dust_band == NULL)
          dust_here = FALSE;
     else dust_here = current_dust_band->dust_present;
     while ((current_dust_band != NULL)
            && (current_dust_band->inner_edge < outside_range)) {
               dust_here = dust_here || current_dust_band->dust_present;
               current_dust_band = current_dust_band->next_band;
          }
     return(dust_here);
}

void update_dust_lanes(min, max, mass, crit_mass,
                       body_inner_bound, body_outer_bound)
double min, max, mass, crit_mass, body_inner_bound, body_outer_bound;
{
     int gas; 
     dust_pointer node1, node2, node3;
     
     dust_left = FALSE;
     if ((mass > crit_mass))
          gas = FALSE;
     else 
          gas = TRUE;
     node1 = dust_head;
     while ((node1 != NULL))
     {
          if (((node1->inner_edge < min) && (node1->outer_edge > max)))
          {
               node2 = (dust_bands *)malloc(sizeof(dust_bands));
               node2->inner_edge = min;
               node2->outer_edge = max;
               if ((node1->gas_present == TRUE))
                    node2->gas_present = gas;
               else 
                    node2->gas_present = FALSE;
               node2->dust_present = FALSE;
               node3 = (dust_bands *)malloc(sizeof(dust_bands));
               node3->inner_edge = max;
               node3->outer_edge = node1->outer_edge;
               node3->gas_present = node1->gas_present;
               node3->dust_present = node1->dust_present;
               node3->next_band = node1->next_band;
               node1->next_band = node2;
               node2->next_band = node3;
               node1->outer_edge = min;
               node1 = node3->next_band;
          }
          else 
               if (((node1->inner_edge < max) && (node1->outer_edge > max)))
               {
                    node2 = (dust_bands *)malloc(sizeof(dust_bands));
                    node2->next_band = node1->next_band;
                    node2->dust_present = node1->dust_present;
                    node2->gas_present = node1->gas_present;
                    node2->outer_edge = node1->outer_edge;
                    node2->inner_edge = max;
                    node1->next_band = node2;
                    node1->outer_edge = max;
                    if ((node1->gas_present == TRUE))
                         node1->gas_present = gas;
                    else 
                         node1->gas_present = FALSE;
                    node1->dust_present = FALSE;
                    node1 = node2->next_band;
               }
               else 
                    if (((node1->inner_edge < min) && (node1->outer_edge > min)))
                    {
                         node2 = (dust_bands *)malloc(sizeof(dust_bands));
                         node2->next_band = node1->next_band;
                         node2->dust_present = FALSE;
                         if ((node1->gas_present == TRUE))
                              node2->gas_present = gas;
                         else 
                              node2->gas_present = FALSE;
                         node2->outer_edge = node1->outer_edge;
                         node2->inner_edge = min;
                         node1->next_band = node2;
                         node1->outer_edge = min;
                         node1 = node2->next_band;
                    }
                    else 
                         if (((node1->inner_edge >= min) && (node1->outer_edge <= max)))
                         {
                              if ((node1->gas_present == TRUE))
                                   node1->gas_present = gas;
                              node1->dust_present = FALSE;
                              node1 = node1->next_band;
                         }
                         else 
                              if (((node1->outer_edge < min) || (node1->inner_edge > max)))
                                   node1 = node1->next_band;
     }
     node1 = dust_head;
     while ((node1 != NULL))
     {
          if (((node1->dust_present)
               && (((node1->outer_edge >= body_inner_bound)
                    && (node1->inner_edge <= body_outer_bound)))))
               dust_left = TRUE;
          node2 = node1->next_band;
          if ((node2 != NULL))
          {
               if (((node1->dust_present == node2->dust_present)
                    && (node1->gas_present == node2->gas_present)))
               {
                    node1->outer_edge = node2->outer_edge;
                    node1->next_band = node2->next_band;
                    free(node2);
               }
          }
          node1 = node1->next_band;
     }
}

double collect_dust(last_mass, a, e, crit_mass, dust_band)
double last_mass, a, e, crit_mass;
dust_pointer dust_band;
{
     double mass_density, temp1, temp2, temp, temp_density, bandwidth, width, volume;
     
     temp = last_mass / (1.0 + last_mass);
     reduced_mass = pow(temp,(1.0 / 4.0));
     r_inner = inner_effect_limit(a, e, reduced_mass);
     r_outer = outer_effect_limit(a, e, reduced_mass);
     if ((r_inner < 0.0))
          r_inner = 0.0;
     if ((dust_band == NULL))
          return(0.0);
     else 
     {
          if ((dust_band->dust_present == FALSE))
               temp_density = 0.0;
          else 
               temp_density = dust_density;
          if (((last_mass < crit_mass) || (dust_band->gas_present == FALSE)))
               mass_density = temp_density;
          else 
               mass_density = K * temp_density / (1.0 + sqrt(crit_mass / last_mass)
                                                  * (K - 1.0));
          if (((dust_band->outer_edge <= r_inner)
               || (dust_band->inner_edge >= r_outer)))
               return(collect_dust(last_mass,a,e,crit_mass, dust_band->next_band));
          else
          {
               bandwidth = (r_outer - r_inner);
               temp1 = r_outer - dust_band->outer_edge;
               if (temp1 < 0.0)
                    temp1 = 0.0;
               width = bandwidth - temp1;
               temp2 = dust_band->inner_edge - r_inner;
               if (temp2 < 0.0)
                    temp2 = 0.0;
               width = width - temp2;
               temp = 4.0 * PI * pow(a,2.0) * reduced_mass
                    * (1.0 - e * (temp1 - temp2) / bandwidth);
               volume = temp * width;
               return(volume * mass_density
                      + collect_dust(last_mass,a,e,crit_mass,
                                     dust_band->next_band));
          }
     }
}


/*--------------------------------------------------------------------------*/
/*   Orbital radius is in AU, eccentricity is unitless, and the stellar     */
/*  luminosity ratio is with respect to the sun.  The value returned is the */
/*  mass at which the planet begins to accrete gas as well as dust, and is  */
/*  in units of solar masses.                                               */
/*--------------------------------------------------------------------------*/

double critical_limit(orbital_radius, eccentricity, stellar_luminosity_ratio)
double orbital_radius, eccentricity, stellar_luminosity_ratio;
{
     double temp, perihelion_dist;
     
     perihelion_dist = (orbital_radius - orbital_radius * eccentricity);
     temp = perihelion_dist * sqrt(stellar_luminosity_ratio);
     return(B * pow(temp,-0.75));
}



void accrete_dust(seed_mass, a, e, crit_mass,
                  body_inner_bound, body_outer_bound)
double *seed_mass, a, e, crit_mass,
     body_inner_bound, body_outer_bound;
{
     double perihelion_dist, new_mass, temp_mass;
     
     new_mass = (*seed_mass);
     do
     {
          temp_mass = new_mass;
          new_mass = collect_dust(new_mass,a,e,crit_mass,
                                  dust_head);
     }
     while (!(((new_mass - temp_mass) < (0.0001 * temp_mass))));
     (*seed_mass) = (*seed_mass) + new_mass;
     update_dust_lanes(r_inner,r_outer,(*seed_mass),crit_mass,body_inner_bound,body_outer_bound);
}



void coalesce_planetesimals(a, e, mass, crit_mass,
                            stellar_luminosity_ratio,
                            body_inner_bound, body_outer_bound)
double a, e, mass, crit_mass, stellar_luminosity_ratio,
     body_inner_bound, body_outer_bound;
{
     planet_pointer node1, node2, node3;
     int coalesced; 
     double temp, dist1, dist2, a3;
     
     coalesced = FALSE;
     node1 = planet_head;
     while ((node1 != NULL))
     {
          node2 = node1;
          temp = node1->a - a;
          if ((temp > 0.0))
          {
               dist1 = (a * (1.0 + e) * (1.0 + reduced_mass)) - a;
               /* x aphelion   */
               reduced_mass = pow((node1->mass / (1.0 + node1->mass)),(1.0 / 4.0));
               dist2 = node1->a
                    - (node1->a * (1.0 - node1->e) * (1.0 - reduced_mass));
          }
          else 
          {
               dist1 = a - (a * (1.0 - e) * (1.0 - reduced_mass));
               /* x perihelion */
               reduced_mass = pow(node1->mass / (1.0 + node1->mass),(1.0 / 4.0));
               dist2 = (node1->a * (1.0 + node1->e) * (1.0 + reduced_mass))
                    - node1->a;
          }
          if (((fabs(temp) <= fabs(dist1)) || (fabs(temp) <= fabs(dist2))))
          {
#ifdef VERBOSE
               printf("Collision between two planetesimals!\n");
#endif
               a3 = (node1->mass + mass) / ((node1->mass / node1->a) + (mass / a));
               temp = node1->mass * sqrt(node1->a) * sqrt(1.0 - pow(node1->e,2.0));
               temp = temp + (mass * sqrt(a) * sqrt(sqrt(1.0 - pow(e,2.0))));
               temp = temp / ((node1->mass + mass) * sqrt(a3));
               temp = 1.0 - pow(temp,2.0);
               if (((temp < 0.0) || (temp >= 1.0)))
                    temp = 0.0;
               e = sqrt(temp);
               temp = node1->mass + mass;
               accrete_dust(&(temp),a3,e,stellar_luminosity_ratio,
                            body_inner_bound,body_outer_bound);
               node1->a = a3;
               node1->e = e;
               node1->mass = temp;
               node1 = NULL;
               coalesced = TRUE;
          }
          else 
               node1 = node1->next_planet;
     }
     if (!(coalesced))
     {
          node3 = (planets *)malloc(sizeof(planets));
          node3->a = a;
          node3->e = e;
          if ((mass >= crit_mass))
               node3->gas_giant = TRUE;
          else 
               node3->gas_giant = FALSE;
          node3->mass = mass;
          if ((planet_head == NULL))
          {
               planet_head = node3;
               node3->next_planet = NULL;
          }
          else 
          {
               node1 = planet_head;
               if ((a < node1->a))
               {
                    node3->next_planet = node1;
                    planet_head = node3;
               }
               else 
                    if ((planet_head->next_planet == NULL))
                    {
                         planet_head->next_planet = node3;
                         node3->next_planet = NULL;
                    }
                    else 
                    {
                         while (((node1 != NULL) && (node1->a < a)))
                         {
                              node2 = node1;
                              node1 = node1->next_planet;
                         }
                         node3->next_planet = node1;
                         node2->next_planet = node3;
                    }
          }
     }
}


planet_pointer distribute_planetary_masses(stellar_mass_ratio,
                                           stellar_luminosity_ratio, inner_dust, outer_dust)
double stellar_mass_ratio, stellar_luminosity_ratio, inner_dust, outer_dust;
{
     double a, e, mass, crit_mass,
     planetesimal_inner_bound, planetesimal_outer_bound;
     
     set_initial_conditions(inner_dust,outer_dust);
     planetesimal_inner_bound = innermost_planet(stellar_mass_ratio);
     planetesimal_outer_bound = outermost_planet(stellar_mass_ratio);
     while (dust_left)
     {
          a = random_number(planetesimal_inner_bound,planetesimal_outer_bound);
          e = random_eccentricity( );
          mass = PROTOPLANET_MASS;
#ifdef VERBOSE
          printf("Checking %f AU.\n",a);
#endif
          if (dust_available(inner_effect_limit(a, e, mass),
                             outer_effect_limit(a, e, mass))) {
#ifdef VERBOSE
                    printf(".. Injecting protoplanet.\n");
#endif
                    dust_density = DUST_DENSITY_COEFF * sqrt(stellar_mass_ratio)
                         * exp(-ALPHA * pow(a,(1.0 / N)));
                    crit_mass = critical_limit(a,e,stellar_luminosity_ratio);
                    accrete_dust(&(mass),a,e,crit_mass,
                                 planetesimal_inner_bound,
                                 planetesimal_outer_bound);
                    if ((mass != 0.0) && (mass != PROTOPLANET_MASS))
                         coalesce_planetesimals(a,e,mass,crit_mass,
                                                stellar_luminosity_ratio,
                                                planetesimal_inner_bound,planetesimal_outer_bound);
#ifdef VERBOSE
                    else printf(".. failed due to large neighbor.\n");
#endif
               }
#ifdef VERBOSE
          else printf(".. failed.\n");
#endif
     }
     return(planet_head);
}



planet_pointer distribute_moon_masses(planetary_mass, stellar_luminosity_ratio,
                                      planet_eccentricity, inner_dust, outer_dust)
double planetary_mass, stellar_luminosity_ratio, planet_eccentricity,
     inner_dust, outer_dust;
{
     double a, e, mass, crit_mass,
     planetesimal_inner_bound, planetesimal_outer_bound;
     
     return(NULL);
}
@EOF

chmod 644 accrete.c

echo x - display.c
cat >display.c <<'@EOF'
void display_system()
{
     planet_pointer node1; 
     int counter; 
     char word[(10)+1]; 
     
     printf("                         SYSTEM  CHARACTERISTICS\n");
     printf("Mass of central star (in solar masses): %4.2lf\n", stellar_mass_ratio);
     printf("Luminosity of central star (relative to the sun): %5.2lf\n",stellar_luminosity_ratio);
     printf("Total main sequence lifetime (in million yrs): %10.3lf\n", (main_seq_life / 1.0E6));
     printf("Current age of stellar system (in million yrs): %10.3lf\n",(age / 1.0E6));
     printf("Radius of habitable ecosphere (AU): %3.3lf\n",r_ecosphere);
     node1 = planet_head;
     counter = 1;
     while (node1 != NULL)
     {
          printf("Planet #%d:\n",counter);
          if (node1->gas_giant)
               printf("Gas giant...\n");
          if (node1->resonant_period)
               printf("In resonant period with primary.\n");
          printf("   Distance from primary star (in A.U.): %7.3lf\n",node1->a);
          printf("   Eccentricity of orbit: %5.3lf\n",node1->e);
          printf("   Mass (in Earth masses): %7.3lf\n",node1->mass * EARTH_MASSES_PER_SOLAR_MASS);
          printf("   Equatorial radius (in Km): %10.1lf\n",node1->radius);
          printf("   Density (in g/cc): %6.3lf\n",node1->density);
          printf("   Escape Velocity (in km/sec): %5.2lf\n",node1->escape_velocity / CM_PER_KM);
          printf("   Smallest molecular weight retained: %5.2lf\n",node1->molecule_weight);
          printf("   Surface acceleration (in cm/sec2): %6.2lf\n",node1->surface_accel);
          if (!(node1->gas_giant))
          {
               printf("   Surface Gravity (in Earth gees): %5.2lf\n",node1->surface_grav);
               printf("   Boiling point of water (celcius): %4.1lf\n",(node1->boil_point - KELVIN_CELCIUS_DIFFERENCE));
               printf("   Surface Pressure (in atmospheres): %5.3lf",(node1->surface_pressure / 1000.0));
               if ((node1->greenhouse_effect) && (node1->surface_pressure > 0.0))
                    printf("     RUNAWAY GREENHOUSE EFFECT\n");
               else 
                    printf("\n");
               printf("   Surface temperature (Celcius): %4.2lf\n",(node1->surface_temp - KELVIN_CELCIUS_DIFFERENCE));
               printf("   Hydrosphere percentage: %6.2lf\n",(node1->hydrosphere * 100.0));
               printf("   Cloud cover percentage: %6.2lf\n",(node1->cloud_cover * 100));
               printf("   Ice cover percentage: %6.2lf\n",(node1->ice_cover * 100));
          }
          printf("   Axial tilt (in degrees): %d\n",node1->axial_tilt);
          printf("   Planetary albedo: %4.3lf\n",node1->albedo);
          printf("   Length of year (in days): %7.2lf\n",node1->orbital_period);
          printf("   Length of day (in hours): %7.2lf\n",node1->day);
          counter++;
          node1 = node1->next_planet;
     }
}
@EOF

chmod 644 display.c

echo x - enviro.c
cat >enviro.c <<'@EOF'
double luminosity(mass_ratio)
double mass_ratio; 
{
     double n; 
     
     if (mass_ratio < 1.0)
          n = 1.75 * (mass_ratio - 0.1) + 3.325;
     else 
          n = 0.5 * (2.0 - mass_ratio) + 4.4;
     return(pow(mass_ratio,n));
}


/*--------------------------------------------------------------------------*/
/*   This function, given the orbital radius of a planet in AU, returns     */
/*   the orbital 'zone' of the particle.                                    */
/*--------------------------------------------------------------------------*/

int orbital_zone(orbital_radius)
double orbital_radius; 
{
     if (orbital_radius < (4.0 * sqrt(stellar_luminosity_ratio)))
          return(1);
     else 
     {
          if ((orbital_radius >= (4.0 * sqrt(stellar_luminosity_ratio))) && (orbital_radius < (15.0 * sqrt(stellar_luminosity_ratio))))
               return(2);
          else 
               return(3);
     }
}


/*--------------------------------------------------------------------------*/
/*   The mass is in units of solar masses, and the density is in units      */
/*   of grams/cc.  The radius returned is in units of km.                   */
/*--------------------------------------------------------------------------*/

double volume_radius(mass, density)
double mass, density;
{
     double volume; 
     
     mass = mass * SOLAR_MASS_IN_GRAMS;
     volume = mass / density;
     return(pow((3.0 * volume) / (4.0 * PI),(1.0 / 3.0)) / CM_PER_KM);
}

/*--------------------------------------------------------------------------*/
/*    Returns the radius of the planet in kilometers.                       */
/*   The mass passed in is in units of solar masses, the orbital radius     */
/*   in A.U.                                                                */
/*   This formula is listed as eq.9 in Fogg's article, although some typos  */
/*   crop up in that eq.  See "The Internal Constitution of Planets", by    */
/*   Dr. D. S. Kothari, Mon. Not. of the Royal Astronomical Society, vol 96 */
/*   pp.833-843, 1936 for the derivation.  Specifically, this is Kothari's  */
/*   eq.23, which appears on page 840.                                      */
/*--------------------------------------------------------------------------*/

double kothari_radius(mass, orbital_radius, giant, zone)
double mass, orbital_radius;
int giant, zone;
{
     double temp, temp2, atomic_weight, atomic_num;
     
     if (zone == 1)
     {
          if (giant)
          {
               atomic_weight = 9.5;
               atomic_num = 4.5;
          }
          else 
          {
               atomic_weight = 15.0;
               atomic_num = 8.0;
          }
     }
     else 
          if (zone == 2)
          {
               if (giant)
               {
                    atomic_weight = 2.47;
                    atomic_num = 2.0;
               }
               else 
               {
                    atomic_weight = 10.0;
                    atomic_num = 5.0;
               }
          }
          else 
          {
               if (giant)
               {
                    atomic_weight = 7.0;
                    atomic_num = 4.0;
               }
               else 
               {
                    atomic_weight = 10.0;
                    atomic_num = 5.0;
               }
          }
     temp = atomic_weight * atomic_num;
     temp = (2.0 * BETA_20 * pow(SOLAR_MASS_IN_GRAMS,(1.0 / 3.0))) / (A1_20 * pow(temp,(1.0 / 3.0)));
     temp2 = A2_20 * pow(atomic_weight,(4.0 / 3.0)) * pow(SOLAR_MASS_IN_GRAMS,(2.0 / 3.0));
     temp2 = temp2 * pow(mass,(2.0 / 3.0));
     temp2 = temp2 / (A1_20 * pow(atomic_num, 2.0));
     temp2 = 1.0 + temp2;
     temp = temp / temp2;
     temp = (temp * pow(mass,(1.0 / 3.0))) / CM_PER_KM;
     return(temp);
}


/*--------------------------------------------------------------------------*/
/*  The mass passed in is in units of solar masses, and the orbital radius  */
/*  is in units of AU.  The density is returned in units of grams/cc.       */
/*--------------------------------------------------------------------------*/

double empirical_density(mass, orbital_radius, gas_giant)
double mass, orbital_radius;
int gas_giant;
{
     double temp; 
     
     temp = pow(mass * EARTH_MASSES_PER_SOLAR_MASS,(1.0 / 8.0));
     temp = temp * pow(r_ecosphere / orbital_radius,(1.0 / 4.0));
     if (gas_giant)
          return(temp * 1.2);
     else 
          return(temp * 5.5);
}


/*--------------------------------------------------------------------------*/
/*  The mass passed in is in units of solar masses, and the equatorial      */
/*  radius is in km.  The density is returned in units of grams/cc.         */
/*--------------------------------------------------------------------------*/

double volume_density(mass, equatorial_radius)
double mass, equatorial_radius;
{
     double volume; 
     
     mass = mass * SOLAR_MASS_IN_GRAMS;
     equatorial_radius = equatorial_radius * CM_PER_KM;
     volume = (4.0 * PI * pow(equatorial_radius,3.0)) / 3.0;
     return(mass / volume);
}


/*--------------------------------------------------------------------------*/
/*  The separation is in units of AU, and both masses are in units of solar */
/*  masses.  The period returned is in terms of Earth days.                 */
/*--------------------------------------------------------------------------*/

double period(separation, small_mass, large_mass)
double separation, small_mass, large_mass;
{
     double period_in_years; 
     
     period_in_years = sqrt(pow(separation,3.0) / (small_mass + large_mass));
     return(period_in_years * DAYS_IN_A_YEAR);
}


/*--------------------------------------------------------------------------*/
/*   Fogg's information for this routine came from Dole "Habitable Planets  */
/* for Man", Blaisdell Publishing Company, NY, 1964.  From this, he came    */
/* up with his eq.12, which is the equation for the base_angular_velocity   */
/* below.  Going a bit further, he found an equation for the change in      */
/* angular velocity per time (dw/dt) from P. Goldreich and S. Soter's paper */
/* "Q in the Solar System" in Icarus, vol 5, pp.375-389 (1966).  Comparing  */
/* to the change in angular velocity for the Earth, we can come up with an  */
/* approximation for our new planet (his eq.13) and take that into account. */
/*--------------------------------------------------------------------------*/

double day_length(mass, radius, orbital_period, eccentricity, giant)
double mass, radius, orbital_period, eccentricity;
int giant;
{
     double base_angular_velocity, planetary_mass_in_grams, k2, temp,
     equatorial_radius_in_cm, change_in_angular_velocity, spin_resonance_period;
     
     spin_resonance = FALSE;
     if (giant)
          k2 = 0.24;
     else 
          k2 = 0.33;
     planetary_mass_in_grams = mass * SOLAR_MASS_IN_GRAMS;
     equatorial_radius_in_cm = radius * CM_PER_KM;
     base_angular_velocity = sqrt(2.0 * J * (planetary_mass_in_grams) / (k2 * pow(equatorial_radius_in_cm, 2.0)));
     /*   This next term describes how much a planet's rotation is slowed by    */
     /*  it's moons.  Find out what dw/dt is after figuring out Goldreich and   */
     /*  Soter's Q'.                                                            */
     change_in_angular_velocity = 0.0;
     temp = base_angular_velocity + (change_in_angular_velocity * age);
     /*   'temp' is now the angular velocity. Now we change from rad/sec to     */
     /*  hours/rotation.                                                           */
     temp = 1.0 / ((temp / radians_per_rotation) * SECONDS_PER_HOUR);
     if (temp >= orbital_period)
     {
          spin_resonance_period = ((1.0 - eccentricity) / (1.0 + eccentricity)) * orbital_period;
          if (eccentricity > 0.1)
          {
               temp = spin_resonance_period;
               spin_resonance = TRUE;
          }
          else 
               temp = orbital_period;
     }
     return(temp);
}


/*--------------------------------------------------------------------------*/
/*   The orbital radius is expected in units of Astronomical Units (AU).    */
/*   Inclination is returned in units of degrees.                           */
/*--------------------------------------------------------------------------*/

int inclination(orbital_radius)
double orbital_radius; 
{
     int temp; 
     
     temp = (int)(pow(orbital_radius,0.2) * about(EARTH_AXIAL_TILT,0.4));
     return(temp % 360);
}


/*--------------------------------------------------------------------------*/
/*   This function implements the escape velocity calculation.  Note that   */
/*  it appears that Fogg's eq.15 is incorrect.                              */
/*  The mass is in units of solar mass, the radius in kilometers, and the   */
/*  velocity returned is in cm/sec.                                         */
/*--------------------------------------------------------------------------*/

double escape_vel(mass, radius)
double mass, radius;
{
     double mass_in_grams, radius_in_cm;
     
     mass_in_grams = mass * SOLAR_MASS_IN_GRAMS;
     radius_in_cm = radius * CM_PER_KM;
     return(sqrt(2.0 * GRAV_CONSTANT * mass_in_grams / radius_in_cm));
}


/*--------------------------------------------------------------------------*/
/*  This is Fogg's eq.16.  The molecular weight (usually assumed to be N2)  */
/*  is used as the basis of the Root Mean Square velocity of the molecule   */
/*  or atom.  The velocity returned is in cm/sec.                           */
/*--------------------------------------------------------------------------*/

double rms_vel(molecular_weight, orbital_radius)
double molecular_weight, orbital_radius;
{
     double exospheric_temp; 
     
     exospheric_temp = EARTH_EXOSPHERE_TEMP / pow(orbital_radius, 2.0);
     return(sqrt((3.0 * MOLAR_GAS_CONST * exospheric_temp) / molecular_weight) * CM_PER_METER);
}


/*--------------------------------------------------------------------------*/
/*   This function returns the smallest molecular weight retained by the    */
/*  body, which is useful for determining the atmosphere composition.       */
/*  Orbital radius is in A.U.(ie: in units of the earth's orbital radius),  *)
    (*  mass is in units of solar masses, and equatorial radius is in units of  */
/*  kilometers.                                                             */
/*--------------------------------------------------------------------------*/

double molecule_limit(orbital_radius, mass, equatorial_radius)
double orbital_radius, mass, equatorial_radius;
{
     double numerator, denominator1, denominator2, escape_velocity, temp;
     
     escape_velocity = escape_vel(mass,equatorial_radius);
     return((3.0 * pow(GAS_RETENTION_THRESHOLD * CM_PER_METER, 2.0) * MOLAR_GAS_CONST * EARTH_EXOSPHERE_TEMP) / pow(escape_velocity, 2.0));
}


/*--------------------------------------------------------------------------*/
/*   This function calculates the surface acceleration of a planet.  The    */
/*  mass is in units of solar masses, the radius in terms of km, and the    */
/*  acceleration is returned in units of cm/sec2.                           */
/*--------------------------------------------------------------------------*/

double acceleration(mass, radius)
double mass, radius;
{
     return(GRAV_CONSTANT * (mass * SOLAR_MASS_IN_GRAMS) / pow(radius * CM_PER_KM, 2.0));
}


/*--------------------------------------------------------------------------*/
/*   This function calculates the surface gravity of a planet.  The         */
/*  acceleration is in units of cm/sec2, and the gravity is returned in     */
/*  units of Earth gravities.                                               */
/*--------------------------------------------------------------------------*/

double gravity(acceleration)
double acceleration; 
{
     return(acceleration / EARTH_ACCELERATION);
}


/*--------------------------------------------------------------------------*/
/*  Note that if the orbital radius of the planet is greater than or equal  */
/*  to R_inner, 99% of it's volatiles are assumed to have been deposited in */
/*  surface reservoirs (otherwise, it suffers from the greenhouse effect).  */
/*--------------------------------------------------------------------------*/

int greenhouse(zone, orbital_radius, greenhouse_radius)
int zone; 
double orbital_radius, greenhouse_radius;
{
     if ((orbital_radius < greenhouse_radius) && (zone == 1))
          return(TRUE);
     else 
          return(FALSE);
}


/*--------------------------------------------------------------------------*/
/*  This implements Fogg's eq.17.  The 'inventory' returned is unitless.    */
/*--------------------------------------------------------------------------*/

double vol_inventory(mass, escape_vel, rms_vel, stellar_mass, zone, greenhouse_effect)
double mass, escape_vel, rms_vel, stellar_mass;
int zone, greenhouse_effect;
{
     double velocity_ratio, proportion_const, temp1, temp2, mass_in_earth_units;
     
     velocity_ratio = escape_vel / rms_vel;
     if (velocity_ratio >= GAS_RETENTION_THRESHOLD)
     {
          switch (zone) {
               case 1:
                    proportion_const = 100000.0;
                    break;
               case 2:
                    proportion_const = 75000.0;
                    break;
               case 3:
                    proportion_const = 250.0;
                    break;
               default:
                    printf("Error: orbital zone not initialized correctly!\n");
                    break;
               }
          mass_in_earth_units = mass * EARTH_MASSES_PER_SOLAR_MASS;
          temp1 = (proportion_const * mass_in_earth_units) / stellar_mass;
          temp2 = about(temp1,0.2);
          if (greenhouse_effect)
               return(temp2);
          else 
               return(temp2 / 100.0);
     }
     else 
          return(0.0);
}


/*--------------------------------------------------------------------------*/
/*  This implements Fogg's eq.18.  The pressure returned is in units of     */
/*  millibars (mb).  The gravity is in units of Earth gravities, the radius */
/*  in units of kilometers.                                                 */
/*--------------------------------------------------------------------------*/

double pressure(volatile_gas_inventory, equatorial_radius, gravity)
double volatile_gas_inventory, equatorial_radius, gravity;
{
     equatorial_radius = EARTH_RADIUS_IN_KM / equatorial_radius;
     return(volatile_gas_inventory * gravity / pow(equatorial_radius, 2.0));
}

/*--------------------------------------------------------------------------*/
/*   This function returns the boiling point of water in an atmosphere of   */
/*   pressure 'surface_pressure', given in millibars.  The boiling point is */
/*   returned in units of Kelvin.  This is Fogg's eq.21.                    */
/*--------------------------------------------------------------------------*/

double boiling_point(surface_pressure)
double surface_pressure; 
{
     double surface_pressure_in_bars; 
     
     surface_pressure_in_bars = surface_pressure / MILLIBARS_PER_BAR;
     return(1.0 / (log(surface_pressure_in_bars) / -5050.5 + 1.0 / 373.0));
}


/*--------------------------------------------------------------------------*/
/*   This function is Fogg's eq.22.  Given the volatile gas inventory and   */
/*   planetary radius of a planet (in Km), this function returns the        */
/*   fraction of the planet covered with water.                             */
/*   I have changed the function very slightly:  the fraction of Earth's    */
/*   surface covered by water is 71%, not 75% as Fogg used.                 */
/*--------------------------------------------------------------------------*/

double hydrosphere_fraction(volatile_gas_inventory, planetary_radius)
double volatile_gas_inventory, planetary_radius;
{
     double temp; 
     
     temp = (0.71 * volatile_gas_inventory / 1000.0) * pow(EARTH_RADIUS_IN_KM / planetary_radius, 2.0);
     if (temp >= 1.0)
          return(1.0);
     else 
          return(temp);
}


/*--------------------------------------------------------------------------*/
/*   Given the surface temperature of a planet (in Kelvin), this function   */
/*   returns the fraction of cloud cover available.  This is Fogg's eq.23.  */
/*   See Hart in "Icarus" (vol 33, pp23 - 39, 1978) for an explanation.     */
/*   This equation is Hart's eq.3.                                          */
/*   I have modified it slightly using constants and relationships from     */
/*   Glass's book "Introduction to Planetary Geology", p.46.                */
/*   The 'CLOUD_COVERAGE_FACTOR' is the amount of surface area on Earth     */
/*   covered by one Kg. of cloud.                                            */
/*--------------------------------------------------------------------------*/

double cloud_fraction(surface_temp, smallest_MW_retained, equatorial_radius, hydrosphere_fraction)
double surface_temp, smallest_MW_retained, equatorial_radius,
     hydrosphere_fraction;
{
     double water_vapor_in_kg, fraction, surface_area, hydrosphere_mass;
     
     if (smallest_MW_retained > WATER_VAPOR)
          return(0.0);
     else 
     {
          surface_area = 4.0 * PI * pow(equatorial_radius, 2.0);
          hydrosphere_mass = hydrosphere_fraction * surface_area * EARTH_WATER_MASS_PER_AREA;
          water_vapor_in_kg = (0.00000001 * hydrosphere_mass) * exp(Q2_36 * (surface_temp - 288.0));
          fraction = CLOUD_COVERAGE_FACTOR * water_vapor_in_kg / surface_area;
          if (fraction >= 1.0)
               return(1.0);
          else 
               return(fraction);
     }
}


/*--------------------------------------------------------------------------*/
/*   Given the surface temperature of a planet (in Kelvin), this function   */
/*   returns the fraction of the planet's surface covered by ice.  This is  */
/*   Fogg's eq.24.  See Hart[24] in Icarus vol.33, p.28 for an explanation. */
/*   I have changed a constant from 70 to 90 in order to bring it more in   */
/*   line with the fraction of the Earth's surface covered with ice, which  */
/*   is approximatly .016 (=1.6%).                                          */
/*--------------------------------------------------------------------------*/

double ice_fraction(hydrosphere_fraction, surface_temp)
double hydrosphere_fraction, surface_temp;
{
     double temp; 
     
     if (surface_temp > 328.0) 
          surface_temp = 328.0;
     temp = pow(((328.0 - surface_temp) / 90.0),5.0);
     if (temp > (1.5 * hydrosphere_fraction))
          temp = (1.5 * hydrosphere_fraction);
     if (temp >= 1.0)
          return(1.0);
     else 
          return(temp);
}


/*--------------------------------------------------------------------------*/
/*  This is Fogg's eq.19.  The ecosphere radius is given in AU, the orbital */
/*  radius in AU, and the temperature returned is in Kelvin.                    */
/*--------------------------------------------------------------------------*/

double eff_temp(ecosphere_radius, orbital_radius, albedo)
double ecosphere_radius, orbital_radius, albedo;
{
     return(sqrt(ecosphere_radius / orbital_radius) * pow((1.0 - albedo) / 0.7,0.25) * EARTH_EFFECTIVE_TEMP);
}


/*--------------------------------------------------------------------------*/
/*  This is Fogg's eq.20, and is also Hart's eq.20 in his "Evolution of     */
/*  Earth's Atmosphere" article.  The effective temperature given is in     */
/*  units of Kelvin, as is the rise in temperature produced by the          */
/*  greenhouse effect, which is returned.                                   */
/*--------------------------------------------------------------------------*/

double green_rise(optical_depth, effective_temp, surface_pressure)
double optical_depth, effective_temp, surface_pressure;
{
     double convection_factor; 
     
     convection_factor = EARTH_CONVECTION_FACTOR * pow((surface_pressure / EARTH_SURF_PRES_IN_MILLIBARS),0.25);
     return(pow((1.0 + 0.75 * optical_depth),0.25) - 1.0) * effective_temp * convection_factor;
}


/*--------------------------------------------------------------------------*/
/*   The surface temperature passed in is in units of Kelvin.               */
/*   The cloud adjustment is the fraction of cloud cover obscuring each     */
/*   of the three major components of albedo that lie below the clouds.     */
/*--------------------------------------------------------------------------*/

double planet_albedo(water_fraction, cloud_fraction, ice_fraction, surface_pressure)
double water_fraction, cloud_fraction, ice_fraction, surface_pressure;
{
     double rock_fraction, cloud_adjustment, components, cloud_contribution,
     rock_contribution, water_contribution, ice_contribution;
     
     rock_fraction = 1.0 - water_fraction - ice_fraction;
     components = 0.0;
     if (water_fraction > 0.0)
          components = components + 1.0;
     if (ice_fraction > 0.0)
          components = components + 1.0;
     if (rock_fraction > 0.0)
          components = components + 1.0;
     cloud_adjustment = cloud_fraction / components;
     if (rock_fraction >= cloud_adjustment)
          rock_fraction = rock_fraction - cloud_adjustment;
     else 
          rock_fraction = 0.0;
     if (water_fraction > cloud_adjustment)
          water_fraction = water_fraction - cloud_adjustment;
     else 
          water_fraction = 0.0;
     if (ice_fraction > cloud_adjustment)
          ice_fraction = ice_fraction - cloud_adjustment;
     else 
          ice_fraction = 0.0;
     cloud_contribution = cloud_fraction * about(CLOUD_ALBEDO,0.2);
     if (surface_pressure == 0.0)
          rock_contribution = rock_fraction * about(AIRLESS_ROCKY_ALBEDO,0.3);
     else 
          rock_contribution = rock_fraction * about(ROCKY_ALBEDO,0.1);
     water_contribution = water_fraction * about(WATER_ALBEDO,0.2);
     if (surface_pressure == 0.0)
          ice_contribution = ice_fraction * about(AIRLESS_ICE_ALBEDO,0.4);
     else 
          ice_contribution = ice_fraction * about(ICE_ALBEDO,0.1);
     return(cloud_contribution + rock_contribution + water_contribution + ice_contribution);
}


/*--------------------------------------------------------------------------*/
/*   This function returns the dimensionless quantity of optical depth,     */
/*   which is useful in determining the amount of greenhouse effect on a    */
/*   planet.                                                                */
/*--------------------------------------------------------------------------*/

double opacity(molecular_weight, surface_pressure)
double molecular_weight, surface_pressure;
{
     double optical_depth; 
     
     optical_depth = 0.0;
     if ((molecular_weight >= 0.0) && (molecular_weight < 10.0))
          optical_depth = optical_depth + 3.0;
     if ((molecular_weight >= 10.0) && (molecular_weight < 20.0))
          optical_depth = optical_depth + 2.34
